package api;

import java.rmi.RemoteException;
import java.util.List;

import system.Computer;
import system.Shared;

/**
 * Models any task that can be executed on a remote machine using <a
 * href="http://en.wikipedia.org/wiki/Divide_and_conquer_algorithm">Divide and
 * conquer algorithm</a>. Every task in the Divide and Conquer tree is
 * identified by an ID. The parent of each task is identified by a parentID.
 * 
 * Any client wanting to run a task using the divide and conquer paradigm in the
 * compute space should implement this interface. Application logic related to
 * the 'Divide' phase is represented by the {@link #decompose() decompose()}
 * method. Application logic related to the 'Conquer' phase is represented by
 * the {@link #compose(List list) compose(List list)} method.
 * 
 * For example, let us consider the implementation of a Fibonacci Series Task
 * that returns the Nth fibonacci number.
 * 
 * In mathematical terms, the sequence F(n) : of Fibonacci numbers is defined by
 * the recurrence relation :
 * 
 * <pre>
 * F(n) = F(n - 1) + F(n - 2)
 * </pre>
 * 
 * with seed values
 * 
 * <pre>
 * F(0) = 0 and F(1) = 1
 * </pre>
 * 
 * class FibonacciTask implementing this interface is expected to contain the
 * following code :
 * 
 * 
 * <pre>
 * class FibonacciTask implements Task&lt;Integer&gt; {
 * 	public Result&lt;Integer&gt; decompose() {
 * 		Result&lt;Integer&gt; r = new ResultImpl&lt;Integer&gt;();
 * 		if (n &lt; 2) {
 * 			// Base case of recursion i.e. F(0) and F(1)
 * 			r.setValue(n);
 * 		} else {
 * 			// Dividing F(n) into F(n-1) and F(n-2)
 * 			List&lt;Task&lt;Integer&gt;&gt; subTasks = new Vector&lt;Task&lt;Integer&gt;&gt;();
 * 
 * 			// Creating new subtasks
 * 			subTasks.add(new FibonacciTask(n - 1, Task.Status.DECOMPOSE, id,
 * 					this.getId()));
 * 			subTasks.add(new FibonacciTask(n - 2, Task.Status.DECOMPOSE, id,
 * 					this.getId()));
 * 
 * 			// Adding the subtasks to a result object and returning it
 * 			r.setSubTasks(subTasks);
 * 		}
 * 		return r;
 * 	}
 * 
 * 	public Result&lt;Integer&gt; compose(List&lt;?&gt; list) {
 * 		int sum = 0;
 * 		for (Integer value : (List&lt;Integer&gt;) list) {
 * 			// Aggregating values produced by base case of recursion (see above)
 * 			sum += value;
 * 		}
 * 		Result&lt;Integer&gt; r = new ResultImpl&lt;Integer&gt;();
 * 		r.setValue(sum);
 * 		return r;
 * 	}
 * }
 * </pre>
 * 
 * 
 * 
 * @author Manasa Chandrasekhar
 * @author Kowshik Prakasam
 */



public interface Task<T> {

	/**
	 * Enum to describe the status of the task during the Divide and the Conquer
	 * phase. If the task's status is set to DECOMPOSE, then it is said to be in
	 * the divide phase of execution where the current task is being split into
	 * smaller subtasks for parallelization on a cluster. If the task's status
	 * is set to COMPOSE, then it is said to be in the conquer phase of
	 * execution where results from smaller tasks are being aggregated.
	 */
	enum Status {
		DECOMPOSE, COMPOSE
	};

	/**
	 * This method models the 'Divide' phase of the <a
	 * href="http://en.wikipedia.org/wiki/Divide_and_conquer_algorithm">Divide
	 * and conquer algorithm</a>. Any subclass implementing this method should
	 * divide the existing task into smaller subtasks, pack the subtasks in a
	 * {@link api.Result Result} object and return them. The returned subtasks
	 * are consumed by a {@link api.Client2Space Space} object by queueing them
	 * again for execution on different machine in the cluster. If the base case
	 * of recursion has been reached during the process of decomposition, then
	 * the value can be returned in the {@link api.Result Result} object,
	 * instead of subtasks.
	 * 
	 * @return A {@link api.Result Result} object containing either subtasks
	 *         that have been created during this decomposition stage, or value
	 *         of a base case in the underlying recursion
	 */
	Result<?> decompose();

	/**
	 * This method models the 'Conquer' phase of the <a
	 * href="http://en.wikipedia.org/wiki/Divide_and_conquer_algorithm">Divide
	 * and conquer algorithm</a>. Any subclass implementing this method should
	 * compose results of smaller subtasks (passed as a parameter) that were
	 * earlier generated by this task during the 'Divide' phase, into a single
	 * value that can be consumed by the parent of this task in the overall
	 * recursion tree.
	 * 
	 * @return A {@link api.Result Result} object containing a value obtained by
	 *         composing results of smaller subtasks that were generated by this
	 *         task in the 'Divide' phase
	 * @param list
	 *            <?> A java.util.List containing results obtained from the
	 *            smaller subtasks that were originally generated by the same
	 *            task
	 */

	Result<?> compose(List<?> list);

	/**
	 * @return Returns the status of this task
	 * 
	 * 
	 */
	Task.Status getStatus();

	/**
	 * Sets the status of this task. This method can be used by a
	 * {@link api.Client2Space Space} object to switch the status of a subtask
	 * after the from DECOMPOSE (after the 'Divide' phase) into COMPOSE (to
	 * start the 'Conquer' phase).
	 * 
	 * 
	 */

	void setStatus(Task.Status s);

	/**
	 * 
	 * @return ID of the parent task in the recursion tree
	 */
	String getParentId();

	/**
	 * 
	 * Sets the ID of the parent task in the recursion tree
	 */
	void setParentId(String id);

	/**
	 * 
	 * @return Unique ID representing this task in the recursion tree
	 */

	String getId();

	/**
	 * 
	 * Sets a unique ID representing this task in the recursion tree
	 */

	void setId(String taskId);

	/**
	 * 
	 * @return Number of smaller subtasks generated by this task at the end of
	 *         the DECOMPOSE ('Divide') phase.
	 */

	int getDecompositionSize();

	/**
	 * 
	 * @return Unique IDs of all child tasks generated by this task at the end
	 *         of the DECOMPOSE ('Divide') phase
	 */
	List<String> getChildIds();

	/**
	 * This method in turn calls the {@link system.Computer.getShared()
	 * system.Computer.getShared()} method to get the shared object stored by each
	 * computer
	 * 
	 * @return The copy of the shared object that is present in the computer
	 *         executing the task
	 * @throws RemoteException
	 *             If the computer throws a remote exception while reading its
	 *             shared object, then this method in turn throws the exception
	 */
	Object getShared() throws RemoteException;

	/**
	 * This method in turn calls the ({@link system.Computer.broadcast(Shared)
	 * system.Computer.broadcast(Shared)} ) to set the value of the new shared
	 * object in the compute pace if its better than the current value.
	 * 
	 * @param shared
	 *            An instance of the shared object whose value has to be set in
	 *            the shared object in Space
	 * @throws RemoteException
	 *             If the computer throws a remote exception while writing to
	 *             its shared object, then this method in turn throws the
	 *             exception
	 */
	void setShared(Shared<?> shared) throws RemoteException;

	/**
	 * Sets the remote computer where the task will be executing at runtime
	 * 
	 * @param computer
	 *            Computer where the task will be executed
	 */
	void setComputer(Computer computer);

	/**
	 * 
	 * @return Computer where the task will be executed at runtime
	 */
	Computer getComputer();
}
